{
   Дорогой друг! Ты делаешь первые шаги в программировании и
используешь  для  этого  простой  и удобный язык Pascal. Для
более быстрого усваивания тебе нужны простые и доступные для
понимания   примеры.   Язык   ПАСКАЛЬ   позволяет   наряду с
небольшими       несложными       программами      создавать
структурированные программы трудоёмких и сложных вычислений.
Чтобы  пользователь  при  составлении  программ  не допускал
ошибок или мог их обнаружить их и исправить, число различных
операторов  языка сведено до минимума. Данный пример поможет
тебе  быстрее освоиться с новым для тебя языком, окунуться в
этот   прекрасный  мир  написания  СВОИХ  программ,  кокорые
будут,  может,  даже  ещё  лучше,  чем  эта.  В этом примере
демонстрируются  и  структура  программ  на паскале, способы
использования    циклов,    структурное    программирования,
константы,  типы,  переменные,  условия  и многое другое. И,
что  самое приятное, эта программа РАБОТАЕТ!!! Hо, хочу тебе
сказать, в этой программе умышленно допущена одна ошибка, и,
если  ты  сможешь  найти  её, ты сможешь считать, что первый
урок ты усвоил.
}

program  uuuuuuuuuuuuuuuuuuuuuuuuuuuuu  ( input , output ) ;
type  uu  =  byte  ;  const uuuuuu = uu ( true ) ; uuu = ( (
uuuuuu  + uuuuuu ) * ( uuuuuu + uuuuuu ) * ( uuuuuu + uuuuuu
)  ) ; uuuuuuuu = ( uuu * ( uuuuuu + uuuuuu ) ) ; uuuuuuuuuu
=  (  uuu  *  (  uuuuuu + uuuuuu ) - ( ( uuuuuu + uuuuuu ) +
uuuuuu  )  )  ;  uuuuuuuuu  =  (  ( uuu + uuuuuu ) * uuu ) ;
uuuuuuuuuuuuu  = ( ( uuu + ( uuuuuu + uuuuuu ) ) * ( uuu + (
uuuuuu  +  uuuuuu  )  )  + uuuuuu ) ; uuuuuuuuuuuuuu = ( ( (
uuuuuu + uuuuuu ) + ( ( uuuuuu + uuuuuu ) + uuuuuu ) ) * uuu
+   (  (  uuuuuu  +  uuuuuu  )  +  uuuuuu  )  +  uuuuuu  ) ;
uuuuuuuuuuuuuuu = ( uuuuuuuu * ( uuuuuu + uuuuuu ) ) ; uuuuu
=  ( uuu * ( ( ( uuuuuu + uuuuuu ) + uuuuuu ) + ( ( uuuuuu +
uuuuuu  )  +  uuuuuu  ) + ( ( uuuuuu + uuuuuu ) + uuuuuu ) +
uuuuuu  )  +  (  ( uuuuuu + uuuuuu ) + uuuuuu ) + ( uuuuuu +
uuuuuu  )  +  (  uuuuuu  + uuuuuu ) ) ; uuuuuuuuuuuuuuuu = (
uuuuuuuuuuuuu  -  uuuuuu  * uuuuuu ) ; uuuuuuuuuuuuuuuuu = (
uuuuuuuuuuuuuuu  +  uuuuuu  *  uuuuuu  )  ; uuuuuuuuuuuu = (
uuuuuuuuuuuuuuu/ ( uuuuuu + uuuuuu ) - ( ( uuuuuu + uuuuuu )
+  uuuuuu ) - ( ( uuuuuu + uuuuuu ) + uuuuuu ) ) ; uuuuuuu =
( uuuuuuuuuuuuuuuu - uuuuuu - uuuuuuuuuuuuuuuuu * ( uuuuuu +
uuuuuu + + uuuu ) + uuuuuu + uuuuuu ) ; uuuuuuuuuuuuuuuuuu :
array  [  uuuuuu  - uuuuuu..uuuuuuuu - ( uuuuuu + uuuuuu ) -
uuuuuu  -  uuuuuu  ] of uu = ( uuuuuuuuu , uuuuuuuuuuuuu , (
(  uuu + ( uuuuuu + uuuuuu ) ) * ( uuu + ( uuuuuu + uuuuuu )
)  +  uuu  )  ,  ( ( uuu + ( uuuuuu + uuuuuu ) ) * ( uuu + (
uuuuuu  + uuuuuu ) ) + uuu ) , ( ( uuu + ( uuuuuu + uuuuuu )
)  *  (  uuu  + ( uuuuuu + uuuuuu ) ) + ( uuu + ( ( uuuuuu +
uuuuuu ) + uuuuuu ) ) ) , uuuuuuuuuuuuuu , uuuuuuuuuuuuuuu ,
uuuuu , ( ( uuu + ( uuuuuu + uuuuuu ) ) * ( uuu + ( uuuuuu +
uuuuuu  ) ) + ( uuu + ( ( uuuuuu + uuuuuu ) + uuuuuu ) ) ) ,
(  (  (  uuu  +  (  uuuuuu + uuuuuu ) ) * ( uuu + ( uuuuuu +
uuuuuu  ) ) + ( uuu + ( ( uuuuuu + uuuuuu ) + uuuuuu ) ) + (
(  uuuuuu  +  uuuuuu ) + uuuuuu ) ) ) , ( ( uuu + ( uuuuuu +
uuuuuu  )  )  *  (  uuu  +  (  uuuuuu + uuuuuu ) ) + uuu ) ,
uuuuuuuuuuuuuuuu  ,  uuuuuuuuuuuuuuuuu  ) ; procedure uuuu ;
assembler  ; asm mov ax , ( ( uuuuuu + uuuuuu ) + uuuuuu ) ;
int  uuuuuuuu end ; procedure uuuuuuuuuuuuuuuuuuuu ; var u :
uu ; uuuuuuuuuuuuuuuuuuu : array [ uuuuuuu .. uuuuuuuuuu * (
uuuuuu  +  uuuuuu  ) ] of uu absolute ( uuuuuuuuuuuuuu + ( (
uuuuuu  + uuuuuu ) + uuuuuu ) ) * uuuuuuuuuuuuuuuu * ( uuu +
(  uuuuuu + uuuuuu ) ) + uuuuuuuuuuuuu + ( ( uuuuuu + uuuuuu
)  +  uuuuuu  )  :  uuuuuuu ; begin uuuu ; for u := uuuuuu -
uuuuuu    *    uuuuuu    to    uuuuuuuuuu    -   uuuuuu   do
uuuuuuuuuuuuuuuuuuu  [  u  *  (  uuuuuu  +  uuuuuu  )  ]  :=
uuuuuuuuuuuuuuuuuu  [  u  ] end ; begin uuuuuuuuuuuuuuuuuuuu
end .
